global exit
global string_length
global print_string
global print_char
global print_newline
global print_uint
global print_int
global string_equals
global read_char
global read_word
global parse_uint
global parse_int
global string_copy
global print_err

section .text
  
; Принимает код возврата и завершает текущий процесс
exit: 
    mov rdi, rax  ; принимаем код возврата 
    mov rax, 60   ; системный вызов 'exit'  
    xor rdi, rdi  ; обнуляем регистр rdi 
    syscall

; Принимает указатель на нуль-терминированную строку, возвращает её длину
string_length:
    xor rax, rax              ; обнуляем аккумулятор
.loop: 
    cmp byte [rdi + rax], 0   ; сравниваем символ строки с нулем 
    je .end                   ; если нуль, то возвращаемся из процедуры
    inc rax                   ; инкрементируем аккумулятор  
    jmp .loop                 ; повторяем цикл 
.end:
    ret                       ; выходим из процедуры

; Принимает указатель на нуль-терминированную строку, выводит её в stdout
print_string:  
    call string_length        ; вычисляем длину строки 
    mov rsi, rdi              ; rsi принимает указатель на строку
    mov rdi, 1                ; rdi принимает номер дескриптора (1 - stdout)
    mov rdx, rax              ; rdx принимает количество байт для вывода
    mov rax, 1                ; системный вызов печати
    syscall                   ; системный вызов   
    ret                       ; выходим из процедуры 

; Принимает указатель на нуль-терминированную строку, выводит её в stdout
print_err:  
    call string_length        ; вычисляем длину строки 
    mov rsi, rdi              ; rsi принимает указатель на строку
    mov rdi, 2                ; rdi принимает номер дескриптора (1 - stdout)
    mov rdx, rax              ; rdx принимает количество байт для вывода
    mov rax, 1                ; системный вызов печати
    syscall                   ; системный вызов   
    ret                       ; выходим из процедуры

; Принимает код символа, номер дескриптора 
print_char:
    push rdi                  ; кладем на стек символ на запись
    mov rdi, 1                ; rdi принимает номер дескриптора (1 - stdout)
    mov rsi, rsp              ; rsi принимает печатаемый символ 
    mov rdx, 1                ; выводим один байт
    mov rax, 1                ; системный вызов записи 
    syscall                   ; системный вызов
    pop rdi                   ; очищаем стек 
    ret                       ; выходим из процедуры

; Переводит строку (выводит символ с кодом 0xA)
print_newline: 
    mov rdi, 0xA              ; передаем в rdi код символа 0xA на печать
    push rdi                  ; сохраняем rdi 
    call print_char           ; вызываем процедуру печати символа
    pop rdi                   ; восстанавливаем rdi 
    ret                       ; выходим из процедуры

; Выводит беззнаковое 8-байтовое число в десятичном формате 
; Совет: выделите место в стеке и храните там результаты деления
; Не забудьте перевести цифры в их ASCII коды.

print_uint:
    mov rax, rdi    ; передаем в аккумулятор число для последующего деления 
    mov rbx, 10     ; делитель 10 кладем в rbx
    push 0          ; нуль-терминатор кладем в стек 
.loop:
    xor rdx, rdx    ; очищаем rdx
    div rbx         ; делим rax на 10, извлекаем последнюю цифру 
    add rdx, 48     ; получаем ASCII код последней цифры 
    push rdx        ; кладем очередную цифру на стек 
    cmp rax, 0      ; остались ли еще цифры?
    jne .loop
.get_digit:
    pop rdi             ; восстанавливаем очередной символ 
    cmp rdi, 0          ; проверяем его на нуль-терминатор 
    je .end             ; если условие соблюдено, то выходим
    call print_char     ; печатаем символа
    jmp .get_digit      ; цикл
.end:
    ret
 

; Выводит знаковое 8-байтовое число в десятичном формате 
print_int:
    test rdi, rdi        ; выставляем флаги для полученного числа 
    jns .unsigned        ; если число без знака, то переходим на метку .unsigned 
    neg rdi              ; если число со знаком, то сделаем его беззнаковым
    push rdi             ; запоминаем число 
    mov rdi, '-'         ; передаем как аргумент '-'
    call print_char      ; печатаем '-'
    pop rdi              ; восстанавливаем число 
.unsigned: 
    call print_uint      ; вызываем процедуру печати беззнакового числа 
    ret                  ; возврат из процедуры 

; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
string_equals:
    call string_length               ; вычисляем длину первой строки
    mov rdx, rax                     ; сохраняем длину первой строки в rdx   
    xchg rdi, rsi                    ; меняем местами указатели на строки  
    call string_length               ; вычисляем длину второй строки 
    cmp rax, rdx                     ; сравниваем длины двух строк                      
    jne .unequal                     ; если длины не равны, то переходим на метку .unequal   
    xor rcx, rcx                     ; обнуляем аккумулятор 
.loop:
    cmp rcx, rax                     ; сравниваем символ второй строки с нулем 
    je .equal                        ; если символ равен нулю, то переходим на метку .tend
    mov dl, byte [rsi + rcx]  
    cmp byte [rdi + rcx], dl         ; сравниваем символы строк 
    jne .unequal                     ; если символы не равны, то переходим на метку .fend 
    inc rcx                          ; инкрементируем аккумулятор              
    jmp .loop                        ; возвращаемся в цикл 
.equal:     
    mov rax, 1                       ; возвращаем 1 через аккумулятор 
    ret                              ; возвращаемся из функции
.unequal: 
    mov rax, 0                       ; возвращаем 0 через аккумулятор 
    ret                              ; возвращаемся из функции 

; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
read_char:
    xor rax, rax           ; обнуляем аккумулятор 
    mov rdi, 0             ; rdi принимает номер дескриптора (0 - stdin) 
    mov rdx, 1             ; читаем один символ 
    push 0                 ; в стеке лежит символ конца потока  
    mov rsi, rsp           ; указываем, куда записываем символ 
    syscall                ; системный вызов 
    pop rax                ; получаем результат в аккумулятор
    ret 

; Принимает: адрес начала буфера, размер буфера
; Читает в буфер слово из stdin, пропуская пробельные символы в начале, .
; Пробельные символы это пробел 0x20, табуляция 0x9 и перевод строки 0xA.
; Останавливается и возвращает 0 если слово слишком большое для буфера
; При успехе возвращает адрес буфера в rax, длину слова в rdx.
; При неудаче возвращает 0 в rax
; Эта функция должна дописывать к слову нуль-терминатор 
read_word:
    xor rax, rax    ; обнуляем аккумулятор 
    xor rcx, rcx    ; обнуляем счетчик 
.loop:
    cmp rcx, rsi    ; сравниваем количество прочитанных символов с размером буфера 
    jae .not_fit    ; если количество символов превышает размер буфера, то выходим 
    push rdx        ; caller-saved
    push rsi        ; caller-saved 
    push rdi        ; caller-saved 
    push rcx        ; caller-saved 
    call read_char  ; читаем очередной символ 
    pop rcx         ; caller-saved 
    pop rdi         ; caller-saved 
    pop rsi         ; caller-saved 
    pop rdx         ; caller-saved 
    cmp al, 0xA     ; сравниваем символ с 0xA 
    je .handle_symbol   ; если равны, то переходим на обработку символа  
    cmp al, 0x9     ; сравниваем символ с 0x9    
    je .handle_symbol   ; если равны, то переходим на обработку символа 
    cmp al, 0x20    ; сравниваем символ с 0x20 
    je .handle_symbol   ; если равны, то переходим на обработку символа 
    cmp al, byte 0  ; проверяем на нуль-терминатор 
    je .end         ; если нуль-терминатор, то это конец слова - выходим из функции
    mov [rdi + rcx], al     ; записываем очередной символ в буфер  
    inc rcx         ; увеличиваем счетчик 
    jmp .loop       ; заходим в цикл 
.not_fit: 
    xor rax, rax    ; обнуляем rax по условию   
    ret             ; возвращаемся
.handle_symbol:
    cmp rcx, 0      ; сравниваем количество прочитанных символов с нулем 
    je .loop        ; если "значащие" символы еще не прочитаны, то заходим в цикл 
.end:
    mov [rdi + rcx], byte 0     ; добавляем нуль-терминатор
    mov rax, rdi    ; кладем в rax указатель на начало буфера 
    mov rdx, rcx    ; кладем в rdx количество прочитанных символов
    ret
    
; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
parse_uint:
    call string_length          ; вычисляем длину строки
    mov rsi, rax                ; кладем длину строки в rsi
    xor rcx, rcx                ; обнуляем счетчик
    xor rdx, rdx                ; обнуляем длину числа
    xor rax, rax                ; обнуляем аккумулятор 
    xor r8, r8                  ; обнуляем r8 
.loop:
    mov r8b, byte [rdi + rcx]   ; получаем следующий символ строки
    cmp r8b, 0                  ; проверяем его на нуль-терминатор
    je .end                     ; если достигнут конец строки, то выходим
    cmp r8b, 57                 ; сравниваем с правой границей цифр в ASCII (57 - код символа '9')
    ja .end                     ; если больше правой границы, то выходим 
    cmp r8b, 48                 ; сравниваем с левой границей цифр в ASCII (48 - код символа '0')
    jb .end                     ; если меньше левой границы, то выходим
    sub r8b, 48                 ; вычисляем саму цифру в десятичном виде
    imul rax, 10                ; сдвигаем аккумулятор
    add rax, r8                 ; прибавляем к аккумулятору цифру 
    inc rdx                     ; инкрементируем длину числа 
    inc rcx                     ; инкрементируем счетчик
    jmp .loop                   ; обратно в цикл 
.end:
    ret

; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
parse_int:
    xor rax, rax            ; обнуляем аккумулятор 
    xor rdx, rdx            ; обнуляем rdx
    cmp byte [rdi], '-'     ; сравниваем первый символ на знак '-'
    jne .unsigned           ; если равно, то переходим на метку .unsigned 
    inc rdi                 ; увеличиваем указатель 
    call parse_uint         ; вызываем процедуру parse_int 
    inc rdx                 ; инкрементируем rdx из-за дополнительного знака '-'
    neg rax                 
    ret                     ; возврат из процедуры 
.unsigned:
    call parse_uint         ; вызываем процедуру parse_int 
    ret                     ; возврат из процедуры

; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
string_copy:
    xor rax, rax             ; обнуляем аккумулятор 
    call string_length       ; вычисляем длину строки
    inc rax                  ; учитываем нуль-терминатор  
    cmp rax, rdx             ; сравниваем длину строки и длину буфера 
    jg .notfit               ; если длина строки больше длины буфера, то переходим на метку .notfit 
    xor rcx, rcx             ; обнуляем счетчик 
.loop: 
    cmp rcx, rax                   ; сравниваем счетчик с длиной строки 
    je .end                        ; если счетчик равен длине строки, то переходим на метку .end 
    mov r8b, byte [rdi + rcx]       ; копируем символ строки в буфер
    mov byte [rsi + rcx], r8b  
    inc rcx                        ; инкрементируем счетчик 
    jmp .loop                      ; входим в цикл 
.notfit:
    mov rax, 0                     ; возвращаем код 0
    ret                            ; возвращаемся из процедуры 
.end:
    dec rax                        ; длина строки без нуля-терминатора 
    ret                            ; возвращаемся из процедуры

